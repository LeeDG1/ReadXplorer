/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package de.cebitec.vamp.dashboard;
  
import de.cebitec.vamp.controller.ViewController;
import de.cebitec.vamp.databackend.connector.ProjectConnector;
import de.cebitec.vamp.databackend.connector.ReferenceConnector;
import de.cebitec.vamp.databackend.dataObjects.PersistantReference; 
import de.cebitec.vamp.databackend.dataObjects.PersistantTrack;
import de.cebitec.vamp.ui.visualisation.AppPanelTopComponent;
import java.awt.BorderLayout;
import java.awt.EventQueue;
import java.beans.IntrospectionException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.BorderFactory;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.border.Border;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.view.OutlineView;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;

    
    //@Override public ExplorerManager getExplorerManager() { return em; }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
/**
 * Top component which displays something.
 */
@ConvertAsProperties(
    dtd = "-//de.cebitec.vamp.dashboard//DashboardWindow//EN",
autostore = false)
@TopComponent.Description(
    preferredID = "DashboardWindowTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "editor", openAtStartup = true)
@ActionID(category = "Tools", id = "de.cebitec.vamp.dashboard.DashboardWindowTopComponent")
@ActionReference(path = "Menu/Tools" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
    displayName = "#CTL_DashboardWindowAction",
preferredID = "DashboardWindowTopComponent")
@Messages({
    "CTL_DashboardWindowAction=Dashboard",
    "CTL_DashboardWindowTopComponent=Dashboard",
    "HINT_DashboardWindowTopComponent=This is a DashboardWindow window"
})
public final class DashboardWindowTopComponent extends TopComponent implements ExplorerManager.Provider {
    
    private ExplorerManager em = new ExplorerManager();
    private OutlineView ov;
    
    
    public void refreshData() {
        this.removeAll();
        this.repaint();
        
        if (!ProjectConnector.getInstance().isConnected()) {
            /*
             * Quickstart:
             * 1. Open a database
             * 2. Import data
            */
            String  sText  = "<html><img src=\""+DashboardWindowTopComponent.class.getResource("splash.png")+"\" /><h2>Visualization and Analysis of MapPed sequences: Quick Start</h2> <p>1. Open a database <br/> "
                    +"2. Import a reference genome <br /> 3. Import a track <br /> 4. Explore your reference genome and tracks <br />"
                    + "5. Run an analysis on your data </p></html>";
            jLabel1.setText (sText);
            
            Border paddingBorder = BorderFactory.createEmptyBorder(100,100,100,100);
            jLabel1.setBorder(BorderFactory.createCompoundBorder(paddingBorder,paddingBorder));
            this.setLayout(new BorderLayout());
            add(jLabel1, BorderLayout.CENTER);
            this.remove(jPanel1);
            jButton1.setVisible(false);
        }
        else {
            jButton1.setVisible(true);
            final List<PersistantReference> dbGens = ProjectConnector.getInstance().getGenomes();

            List<PersistantTrack> dbTracks = ProjectConnector.getInstance().getTracks();
            
            final Map<PersistantReference,List<PersistantTrack>> genomesandtracks = 
                    ProjectConnector.getInstance().getGenomesAndTracks();

            Node rootNode = new AbstractNode(new Children.Keys() {

                @Override
                protected Node[] createNodes(Object t) {
                    PersistantReference genome = (PersistantReference) t;
                    try { 
                        List<PersistantTrack> tracks = genomesandtracks.get(genome);
                        
                        if (tracks!=null) {
                            List<Item> trackItems = new ArrayList<Item> ();
                            for(PersistantTrack track : tracks) {
                                trackItems.add(new Item(track));
                            }
                            return new Node[] { new ItemNode(new Item(genome), new ItemChildren(trackItems)) };
                        }
                        else return new Node[] { new ItemNode(new Item(genome)) };
                    } catch (IntrospectionException ex) {
                        Exceptions.printStackTrace(ex);
                        return new Node[] {};
                    }
                }
                
                protected void addNotify() {
                    super.addNotify();
                    this.setKeys(genomesandtracks.keySet());
                    //this.setKeys(dbGens);
                }
                
            });
            ov = new OutlineView(); //Set the columns of the outline view,
            
            //do not show the default property window
            //this outlineview is meant to be a readonly list
            ov.setDefaultActionAllowed(false);
            //using the name of the property 
            //followed by the text to be displayed in the column header: 
            ov.setPropertyColumns( "description", "Description", "timestamp", "Date", "mark", "Mark for action"); 
            //Hide the root node, since we only care about the children: 
            ov.getOutline().setRootVisible(false); //Add the OutlineView to the TopComponent: 
            ov.getOutline().setDefaultRenderer(Node.Property.class,
                                            new CustomOutlineCellRenderer());
            
            //use GroupLayout to show the "open selected" button directly under the outlineview
            GroupLayout layout = new GroupLayout(this);
            setLayout(layout);
            layout.setAutoCreateGaps(true);
            layout.setAutoCreateContainerGaps(true);
            layout.setHorizontalGroup(
                 layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                    .addComponent(ov)
                    .addComponent(jButton1));

            layout.setVerticalGroup(
                layout.createSequentialGroup()
                .addComponent(ov, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                // important: add a gap under the button to get the users 
                // attention to it, i.e. it is not to far away from the outline view
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED,
                     GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    );
            em.setRootContext(rootNode); //Put the Nodes into the Lookup of the TopComponent, 
            
            //expand all nodes
            for(Node n : em.getRootContext().getChildren().getNodes()) {
                ov.expandNode(n);
            }
            //or like this for one special node: 
            //ov.expandNode(em.getRootContext().getChildren().getNodeAt(0));
        }
        this.repaint();
    }

    
    
    
    public DashboardWindowTopComponent() {
        initComponents();
        setName(Bundle.CTL_DashboardWindowTopComponent());
        setToolTipText(Bundle.HINT_DashboardWindowTopComponent());
        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.FALSE);
        putClientProperty(TopComponent.PROP_DRAGGING_DISABLED, Boolean.FALSE);
        putClientProperty(TopComponent.PROP_UNDOCKING_DISABLED, Boolean.FALSE);
        
        this.refreshData();
        ProjectConnector.getInstance().addObserver(new Observer() {

            @Override 
            public void update(Observable o, Object arg) {
                
                //dirty fix for a bug in h2 database, that is occuring, when trying
                //to delete two or more references
                //the code waits 100ms before updating the dashboard to ensure 
                //that the reference data has been fully deleted
                new Thread() {
                    @Override public synchronized void run() {
                        try {
                            this.wait(200);
                        } catch (InterruptedException ex) {
                            Exceptions.printStackTrace(ex);
                        }
                        try {
                            //run gui updates separately in the AWT Thread
                            EventQueue.invokeLater(new Runnable() {
                                @Override
                                public void run() {
                                    refreshData();
                                }
                            });
                        }
                        catch(Exception e) {
                            Logger.getLogger(this.getClass().getName()).log(Level.WARNING, 
                            e.getMessage());
                        }
                    }
                }.start();
                
            }
        
        }); 
    }
    
    @Override public ExplorerManager getExplorerManager() { return em; }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(DashboardWindowTopComponent.class, "DashboardWindowTopComponent.jLabel1.text")); // NOI18N

        jPanel1.setLayout(new java.awt.BorderLayout());

        org.openide.awt.Mnemonics.setLocalizedText(jButton1, org.openide.util.NbBundle.getMessage(DashboardWindowTopComponent.class, "DashboardWindowTopComponent.jButton1.text")); // NOI18N
        jButton1.setBounds(new java.awt.Rectangle(0, 0, 400, 29));
        jButton1.setMargin(new java.awt.Insets(15, 50, 15, 50));
        jButton1.setMaximumSize(new java.awt.Dimension(400, 29));
        jButton1.setMinimumSize(new java.awt.Dimension(400, 29));
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        jPanel1.add(jButton1, java.awt.BorderLayout.CENTER);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addGap(0, 312, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 354, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 248, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    /* iterate through all given nodes and treir children 
     * and return only those with getMark() = true
     */
    private static List<Node> getAllMarkedNodes(List<Node> nodes) {
        ArrayList<Node> selectedNodes = new ArrayList<Node>(); 
        for(Node n : nodes) {
            ItemNode node = (ItemNode) n;
            Item item = node.getData();
            //ov.getOutline().getSelectedRows() rowat()
            if (item.getMark()) {
                /*Logger.getLogger(this.getClass().getName()).log(Level.INFO, 
                "Node "+item.getTitle()+" is selected!");*/
                selectedNodes.add(n);
            }
            List<Node> markedChildren = Arrays.asList(n.getChildren().getNodes());
            selectedNodes.addAll(getAllMarkedNodes(markedChildren));
        }
        return selectedNodes;
    }
    
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        List<Node> selectedNodes = getAllMarkedNodes(Arrays.asList(em.getRootContext().getChildren().getNodes()));
            
        //scan all selected nodes and save them to a map of the form:
        // GenomeID -> List<ReferenceID>
        selectedNodes.addAll(Arrays.asList(em.getSelectedNodes()));
        
        HashMap<Long,HashSet<Long>> genomesandtracks_toopen = new HashMap<Long,HashSet<Long>>();
        for(Node n : selectedNodes) {
            ItemNode node = (ItemNode) n;
            Item item = node.getData();
            if (item.getKind()==Item.Kind.GENOME) {
                if (!genomesandtracks_toopen.containsKey(item.getID())) {
                    genomesandtracks_toopen.put(item.getID(), new HashSet<Long>()); 
                }
            }
            else {
                if (!genomesandtracks_toopen.containsKey(item.getRefID())) {
                    genomesandtracks_toopen.put(item.getRefID(), new HashSet<Long>()); 
                }
                genomesandtracks_toopen.get(item.getRefID()).add(item.getID());
            }
        }
        
        
        Map<PersistantReference, List<PersistantTrack>> genomesAndTracks 
                = ProjectConnector.getInstance().getGenomesAndTracks();
        
        for(Long genome_id : genomesandtracks_toopen.keySet()) {
            Set<Long> track_ids = genomesandtracks_toopen.get(genome_id);
            
            //ReferenceConnector rc = new ReferenceConnector( genome_id.intValue() );
            ReferenceConnector rc = ProjectConnector.getInstance().getRefGenomeConnector(genome_id.intValue());
            PersistantReference genome = rc.getRefGenome();
            //ProjectConnector.getInstance().getGenomes()
            
            //open reference genome now
            AppPanelTopComponent appPanelTopComponent = new AppPanelTopComponent();
            
            appPanelTopComponent.open();
            appPanelTopComponent.getLookup().lookup(ViewController.class).openGenome(genome);
            appPanelTopComponent.setName(appPanelTopComponent.getLookup().lookup(ViewController.class).getDisplayName());
            appPanelTopComponent.requestActive();
             
            
            //open tracks for this genome now
            List<PersistantTrack> all_tracks_for_this_genome = genomesAndTracks.get(genome);
            
            List<PersistantTrack> tracks_to_show = new ArrayList<PersistantTrack>();
            
            for(PersistantTrack track : all_tracks_for_this_genome) {
                if (track_ids.contains(new Long(track.getId()))) {
                    tracks_to_show.add(track);
                }
            }
                
            appPanelTopComponent.getLookup().lookup(ViewController.class).openTracksOnCurrentGenome(tracks_to_show);
            
        }
        //ReferenceViewer referenceViewer = AppPanelTopComponent.findInstance().getReferenceViewer();
        
    }//GEN-LAST:event_jButton1ActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables
    
    @Override
    public void componentOpened() {
        this.refreshData();
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
}
