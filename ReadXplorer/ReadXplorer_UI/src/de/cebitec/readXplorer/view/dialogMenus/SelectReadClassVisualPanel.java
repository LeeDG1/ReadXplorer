package de.cebitec.readXplorer.view.dialogMenus;

import de.cebitec.readXplorer.api.objects.JobPanel;
import java.util.prefs.Preferences;
import org.openide.util.NbPreferences;

/**
 * A visual wizard job panel. It offers to select read mapping classes and
 * unique or all mapped reads for any further processing.
 *
 * @author Rolf Hilker <rhilker at cebitec.uni-bielefeld.de>
 */
public class SelectReadClassVisualPanel extends JobPanel {
    
    private static final long serialVersionUID = 1L;
    private boolean usingADBTrack;
    private final String wizardName;

    /**
     * A visual wizard job panel. It offers to select read mapping classes and
     * unique or all mapped reads for any further processing.
     * @param wizardName the name of the corresponding wizard
     */
    public SelectReadClassVisualPanel(String wizardName) {
        this.wizardName = wizardName;
        this.usingADBTrack = false;
        this.initComponents();
        this.updateCheckBoxes();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        descriptionScrollPane = new javax.swing.JScrollPane();
        decriptionTextArea = new javax.swing.JTextArea();
        checkBoxPerfect = new javax.swing.JCheckBox();
        checkBoxBestMatch = new javax.swing.JCheckBox();
        checkBoxCommon = new javax.swing.JCheckBox();
        checkBoxUnique = new javax.swing.JCheckBox();
        jSeparator1 = new javax.swing.JSeparator();

        decriptionTextArea.setEditable(false);
        decriptionTextArea.setBackground(new java.awt.Color(240, 240, 240));
        decriptionTextArea.setColumns(20);
        decriptionTextArea.setFont(new java.awt.Font("Tahoma", 0, 11)); // NOI18N
        decriptionTextArea.setLineWrap(true);
        decriptionTextArea.setRows(5);
        decriptionTextArea.setText(org.openide.util.NbBundle.getMessage(SelectReadClassVisualPanel.class, "SelectReadClassVisualPanel.decriptionTextArea.text")); // NOI18N
        decriptionTextArea.setWrapStyleWord(true);
        descriptionScrollPane.setViewportView(decriptionTextArea);

        checkBoxPerfect.setSelected(true);
        org.openide.awt.Mnemonics.setLocalizedText(checkBoxPerfect, org.openide.util.NbBundle.getMessage(SelectReadClassVisualPanel.class, "SelectReadClassVisualPanel.checkBoxPerfect.text")); // NOI18N
        checkBoxPerfect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkBoxPerfectActionPerformed(evt);
            }
        });

        checkBoxBestMatch.setSelected(true);
        org.openide.awt.Mnemonics.setLocalizedText(checkBoxBestMatch, org.openide.util.NbBundle.getMessage(SelectReadClassVisualPanel.class, "SelectReadClassVisualPanel.checkBoxBestMatch.text")); // NOI18N
        checkBoxBestMatch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkBoxBestMatchActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(checkBoxCommon, org.openide.util.NbBundle.getMessage(SelectReadClassVisualPanel.class, "SelectReadClassVisualPanel.checkBoxCommon.text")); // NOI18N
        checkBoxCommon.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkBoxCommonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(checkBoxUnique, org.openide.util.NbBundle.getMessage(SelectReadClassVisualPanel.class, "SelectReadClassVisualPanel.checkBoxUnique.text")); // NOI18N
        checkBoxUnique.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkBoxUniqueActionPerformed(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(descriptionScrollPane)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(checkBoxBestMatch)
                            .addComponent(checkBoxCommon)
                            .addComponent(checkBoxPerfect))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(checkBoxUnique)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(descriptionScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 108, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(checkBoxPerfect)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(checkBoxBestMatch)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(checkBoxCommon)
                        .addContainerGap(14, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(checkBoxUnique))
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void checkBoxCommonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkBoxCommonActionPerformed
        if (this.checkBoxCommon.isSelected()) {
            this.checkBoxUnique.setSelected(false);
        }
        this.checkBoxUnique.setEnabled(!this.checkBoxCommon.isSelected() && !this.usingADBTrack);
        firePropertyChange(ChangeListeningWizardPanel.PROP_VALIDATE, null, isRequiredInfoSet());
    }//GEN-LAST:event_checkBoxCommonActionPerformed

    private void checkBoxUniqueActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkBoxUniqueActionPerformed
        if (this.checkBoxUnique.isSelected()) {
            this.checkBoxCommon.setSelected(false);
        }
        this.checkBoxCommon.setEnabled(!this.checkBoxUnique.isSelected());
        firePropertyChange(ChangeListeningWizardPanel.PROP_VALIDATE, null, isRequiredInfoSet());
    }//GEN-LAST:event_checkBoxUniqueActionPerformed

    private void checkBoxPerfectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkBoxPerfectActionPerformed
        firePropertyChange(ChangeListeningWizardPanel.PROP_VALIDATE, null, isRequiredInfoSet());
    }//GEN-LAST:event_checkBoxPerfectActionPerformed

    private void checkBoxBestMatchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkBoxBestMatchActionPerformed
        firePropertyChange(ChangeListeningWizardPanel.PROP_VALIDATE, null, isRequiredInfoSet());
    }//GEN-LAST:event_checkBoxBestMatchActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox checkBoxBestMatch;
    private javax.swing.JCheckBox checkBoxCommon;
    private javax.swing.JCheckBox checkBoxPerfect;
    private javax.swing.JCheckBox checkBoxUnique;
    private javax.swing.JTextArea decriptionTextArea;
    private javax.swing.JScrollPane descriptionScrollPane;
    private javax.swing.JSeparator jSeparator1;
    // End of variables declaration//GEN-END:variables

    /**
     * @return <cc>true</cc>, if at least one read class is selected, 
     * <cc>false</cc> otherwise
     */
    @Override
    public boolean isRequiredInfoSet() {
        return  this.checkBoxPerfect.isSelected() ||
                this.checkBoxBestMatch.isSelected() ||
                this.checkBoxCommon.isSelected();
    }
    
    /**
     * @return <cc>true</cc>, if the perfect match class is selected in this 
     * panel, <cc>false</cc> otherwise.
     */
    public boolean isPerfectSelected() {
        return this.checkBoxPerfect.isSelected();
    }
    
    /**
     * @return <cc>true</cc>, if the best match class is selected in this
     * panel, <cc>false</cc> otherwise.
     */
    public boolean isBestMatchSelected() {
        return this.checkBoxBestMatch.isSelected();
    }
    
    /**
     * @return <cc>true</cc>, if the common match class is selected in this
     * panel, <cc>false</cc> otherwise.
     */
    public boolean isCommonMatchSelected() {
        return this.checkBoxCommon.isSelected();
    }
    
    /**
     * @return <cc>true</cc>, if only unique reads are selected in this
     * panel, <cc>false</cc> if all reads shall be used.
     */
    public boolean isUniqueSelected() {
        return this.checkBoxUnique.isSelected();
    }
    
    @Override
    public String getName() {
        return "Read Classification Selection";
    }
    
    /**
     * @param usingADBTrack true, if the wizard is run on a track stored 
     * completely in the DB, false otherwise.
     */
    public void setUsingDBTrack(boolean usingADBTrack) {
        this.usingADBTrack = usingADBTrack;
        if (this.usingADBTrack) {
            this.checkBoxUnique.setSelected(!usingADBTrack);
            this.checkBoxUnique.setEnabled(!usingADBTrack);
        }
    }

    /**
     * Updates the checkboxes for the read classes with the globally stored
     * settings for this wizard. If no settings were stored, the default
     * configuration is chosen.
     */
    private void updateCheckBoxes() {
        Preferences pref = NbPreferences.forModule(Object.class);
        boolean isPerfectSelected = pref.get(wizardName + SelectReadClassWizardPanel.PROP_PERFECT_SELECTED, "1").equals("1");
        boolean isBestMatchSelected = pref.get(wizardName + SelectReadClassWizardPanel.PROP_BEST_MATCH_SELECTED, "1").equals("1");
        boolean isCommonMatchSelected = pref.get(wizardName + SelectReadClassWizardPanel.PROP_COMMON_MATCH_SELECTED, "0").equals("1");
        boolean isUniqueSelected = pref.get(wizardName + SelectReadClassWizardPanel.PROP_UNIQUE_SELECTED, "0").equals("1");
        this.checkBoxPerfect.setSelected(isPerfectSelected);
        this.checkBoxBestMatch.setSelected(isBestMatchSelected);
        this.checkBoxCommon.setSelected(isCommonMatchSelected);
        this.checkBoxUnique.setSelected(isUniqueSelected);
    }
    
}
