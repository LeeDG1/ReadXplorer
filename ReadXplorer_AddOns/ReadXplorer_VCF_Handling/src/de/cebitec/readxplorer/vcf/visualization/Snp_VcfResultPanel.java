/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package de.cebitec.readxplorer.vcf.visualization;

import de.cebitec.readXplorer.databackend.ResultTrackAnalysis;
import de.cebitec.readXplorer.util.UneditableTableModel;
import de.cebitec.readXplorer.view.analysis.ResultTablePanel;
import de.cebitec.readXplorer.view.tableVisualization.TableUtils;
import de.cebitec.readXplorer.view.tableVisualization.tableFilter.TableRightClickFilter;
import java.util.List;
import java.util.Map;
import javax.swing.DefaultListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;
import org.broadinstitute.variant.variantcontext.VariantContext;

/**
 *
 * @author Marie
 */
public class Snp_VcfResultPanel extends  ResultTablePanel {
    
    public static final String SOURCE = "Source";
    public static final String CONTIG = "Contig";
    public static final String START = "Start";
    public static final String STOP = "Stop";
    public static final String ALLELES = "Alleles";
    public static final String GENOTYPE = "Genotype";
    public static final String LOG10ERROR = "Quality";
    public static final String FILTERS = "Filter";
    public static final String ATTRIBUTES = "Attributes";
    
    private static final long serialVersionUID = 1L;
    private Map<String, Integer> vcfStatsMap;
    private Snp_VcfResult completeVcfData;
    private final TableRightClickFilter<UneditableTableModel> tableFilter;
    private Object[] rowData;

    /**
     * Creates new form Snp_VcfResultPanel
     */
    public Snp_VcfResultPanel() {
        initComponents();
        final int sourColumn = 3;
        final int trackColumn = 2;
        final int chromColumn = 1;
        tableFilter = new TableRightClickFilter<>(UneditableTableModel.class, sourColumn, trackColumn);
        this.vcfTable.getTableHeader().addMouseListener(tableFilter);
        //ensures number of lines will adapt to number of translations (features) for each snp
        
        
        DefaultListSelectionModel model = (DefaultListSelectionModel) vcfTable.getSelectionModel();
        model.addListSelectionListener(new ListSelectionListener() {
            

            @Override
            public void valueChanged(ListSelectionEvent lse) {
                TableUtils.showPosition(vcfTable, sourColumn, chromColumn, getBoundsInfoManager());
                
            }
        });
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        vcfTable = new javax.swing.JTable();

        setPreferredSize(new java.awt.Dimension(1200, 304));

        vcfTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Source", "Contig", "Start", "Stop", "Alleles", "Genotypes", "log 10Error", "Filters", "Attributes"
            }
        ));
        jScrollPane1.setViewportView(vcfTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 589, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 304, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable vcfTable;
    // End of variables declaration//GEN-END:variables

    

    @Override
    public int getDataSize() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void addResult(ResultTrackAnalysis newResult) {
        if (newResult instanceof Snp_VcfResult) {
            Snp_VcfResult vcfData = (Snp_VcfResult)newResult;
            
            if (this.completeVcfData == null){
                this.completeVcfData = vcfData;
                this.vcfStatsMap = vcfData.getStatsMap();
                vcfStatsMap.put(SOURCE, 0);
                vcfStatsMap.put(CONTIG, 0);
                vcfStatsMap.put(START, 0);
                vcfStatsMap.put(STOP, 0);
                vcfStatsMap.put(ALLELES, 0);
                vcfStatsMap.put(GENOTYPE, 0);
                vcfStatsMap.put(LOG10ERROR, 0);
                vcfStatsMap.put(FILTERS, 0);
                vcfStatsMap.put(ATTRIBUTES, 0);
            } else {
                this.completeVcfData.getSnpVcfList().addAll(vcfData.getSnpVcfList());
            }
            final int snpVcfDataSize = 10;
            List<VariantContext> snpVcf = vcfData.getSnpVcfList();
            DefaultTableModel m = (DefaultTableModel) vcfTable.getModel();
            
            for (VariantContext vc : snpVcf){
                int i = 0;
                rowData = new Object[snpVcfDataSize];
                rowData[i++] = vc.getSource();
                rowData[i++] = vc.getChr();
                rowData[i++] = vc.getStart();
                rowData[i++] = vc.getEnd();
                rowData[i++] = vc.getAlleles();
                rowData[i++] = vc.getGenotypes(); //vorverarbeitung
                rowData[i++] = vc.getLog10PError();
                rowData[i++] = vc.getFilters();  //vorverarbeitung
                rowData[i++] = vc.getAttributes(); //evtl. eigene spalten für immer vorkommende einträge, rest zusammenfassen
                 m.addRow(rowData);
             }
        }
        
    }
}
